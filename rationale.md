In the original version of this project, the JavaScript code was written as one large object (`GymApp`) that handled everything: storing data in localStorage, enforcing booking rules, updating the DOM, sending fake emails, processing fake payments, and logging messages. This violated the Single Responsibility Principle, because a single object had too many unrelated responsibilities. It was also hard to test or change one piece of behavior without touching several others.

In the refactored version, I separated the system into focused classes, each with a clear role. `ClassRepo` and `MemberRepo` are responsible only for managing data for classes and members, including loading from and saving to localStorage. They do not know anything about payments, emails, or the DOM. `GymService` contains the domain logic: validating input, checking that IDs are unique, making sure that classes are not over capacity, charging a fee for each booking, and updating the memberâ€™s outstanding fees. This keeps business rules in one place, independent from the UI or storage details. `PaymentProvider`, `Mailer`, and `Logger` are infrastructure services. They implement side effects (console logging, fake payments, and fake emails) behind simple interfaces so that they can be replaced later without changing the domain logic.

`GymController` acts as the UI layer. It connects the DOM to the domain service by listening to button clicks and form inputs, calling methods on `GymService`, and then updating the HTML using `renderClasses` and `renderMember`. Errors thrown from the domain layer are caught in the controller and shown to the user with `alert`, which keeps error handling out of the core logic. This separation of concerns improves readability and makes it easier to reason about the code: repositories handle persistence, the service handles rules, the controller handles the browser, and the infrastructure classes handle external effects.

The new design also improves compliance with the Open/Closed Principle. For example, if I want to support a different payment provider, I can create another class with the same `charge(amount, card)` interface and pass it into the `GymService` constructor instead of `PaymentProvider`. The same approach works for replacing the email sender or changing the logging strategy. Because `GymService` depends only on abstractions (objects that implement specific methods), the behavior of the system can be extended without modifying existing domain logic. Overall, the refactoring reduces coupling, respects SOLID principles, and results in a design that is easier to maintain and extend.
